<html>
<head>
<title>
IFS Fern
</title>
</head>
<body bgcolor="#ffffff">
<center>
<h1>How to create the IFS Fern</h1>
Written by <a href="../">Paul Bourke</a><br>
January 1988
</center>
<p><hr><p>

<p><center>
<img src="realfern.gif">
</center>
<p>

<table width=100%><tr><td valign=top width=50%>
One of the very common and attractive forms generated by Iterated
Function Systems (IFS) is the fern leaf shown on the right.
The following will describe how to generate this form and allow
the reader to experiment with other IFS generators.
<p>
Iterated function systems are described by repeatedly computing
terms in two series, one series describes the x coordinate and the
other series the y coordinate. The equations describe translation,
scaling, rotation, and shearing of points in a plane with the 
restriction that the transformations are "affine".
<p>
The general form of the series are as follows<p>
<center>
x<sub>n+1</sub> = a x<sub>n</sub> + b y<sub>n</sub> + c<p>
y<sub>n+1</sub> = d x<sub>n</sub> + e y<sub>n</sub> + f<p>
</center>
A point is drawn at each pair (x<sub>i</sub>,y<sub>i</sub>) for
i greater than some number, typically 10 to 100.
<p>
The magic is in finding the values of (a,b,c,d,e,f) that give the
desired form. In many application it is necessary to have a number
of sets of (a,b,c,d,e,f). As the series is being generated a particular
set is chosen at random for each term. Such IFS systems are often known
as Random Iterated Function Systems.
</td><td valign=top align=center width=50%>
<img src="fern1.gif">
</td></tr></table>
<p>
<table width=100%><tr><td valign=top width=50%>
The fern can be constructed using the table of value on the right.
<p>
It turns out that if the different sets of (a,b,c,d,e,f) are chosen
with appropriate probabilities then the fern will "emerge" much faster
and evenly than if the sets are chosen with equal chance. The last
row in the table gives the optimal probabilities.
<p>
The fern above resulted from 100 thousand (10<sup>5</sup>) iterations,
that is, 100 thousand points are drawn (of course when drawn on the bitmap
many will overlap)
</td><td width=50%>
<table cellspacing=1 cellpadding=6 border=1 align=center><tr>
<td>-</td>
<td>set1</td>
<td>set2</td>
<td>set3</td>
<td>set4</td>
</tr><tr>
<td>a</td>
<td>0.0</td>
<td>0.2</td>
<td>-0.15</td>
<td>0.75</td>
</tr><tr>
<td>b</td>
<td>0.0</td>
<td>-0.26</td>
<td>0.28</td>
<td>0.04</td>
</tr><tr>
<td>c</td>
<td>0.0</td>
<td>0.23</td>
<td>0.26</td>
<td>-0.04</td>
</tr><tr>
<td>d</td>
<td>0.16</td>
<td>0.22</td>
<td>0.24</td>
<td>0.85</td>
</tr><tr>
<td>e</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
<td>0.0</td>
</tr><tr>
<td>f</td>
<td>0.0</td>
<td>1.6</td>
<td>0.44</td>
<td>1.6</td>
</tr><tr>
<td>p</td>
<td>0.1</td>
<td>0.08</td>
<td>0.08</td>
<td>0.74</td>
</tr><tr>
</tr></table>
</td></tr></table>
<p>
The image is self similar at all scales, one can zoom in as far as
one wishes and the fronds will continue to resolve themselves. For
example, the following image is a zoom in by 50. Note however that
it takes an ever increasing number of iterations to resolve the image
as the zoom factor increases, this image took 100 million 
(10<sup>8</sup>) iterations.<p>
<center>
<img src="fern2.gif" border=2>
</center>
<p>
<h3>C Source</h3>
Some  straightforward C source is given below which generates the
figure shown above. Note, you will have to supply your own image
drawing tools.
<pre>
#include "stdio.h"
#include "stdlib.h"
#include "math.h"
#include "paulslib.h"
#include "bitmaplib.h"

#define NX 1000
#define NY 1000

double a[4] = {0.0,0.2,-0.15,0.75};
double b[4] = {0.0,-0.26,0.28,0.04};
double c[4] = {0.0,0.23,0.26,-0.04};
double d[4] = {0.16,0.22,0.24,0.85};
double e[4] = {0.0,0.0,0.0,0.0};
double f[4] = {0.0,1.6,0.44,1.6};

int main(int argc,char **argv)
{
   int i,j,k;
   int n = 1000;
   int ix,iy;
   double r,x,y,xlast=0,ylast=0;
   double xmin=1e32,xmax=-1e32,ymin=1e32,ymax=-1e32,scale,xmid,ymid;
   BITMAP *image;
   BITMAP white = {255,255,255};
   BITMAP black = {0,0,0};

   if (argc &lt; 2) {
      fprintf(stderr,"Usage: %s nsteps\n",argv[0]);
      exit(0);
   }
   n = atoi(argv[1]);

   image = CreateBitmap(NX,NY);
   EraseBitmap(image,NX,NY,white);

   for (j=0;j&lt;2;j++) {
      for (i=0;i&lt;n;i++) {
         r = rand() % 100;
         if (r &lt; 10)
            k = 0;
         else if (r &lt; 18)
            k = 1;
         else if (r &lt; 26)
            k = 2;
         else
            k = 3;
         x = a[k] * xlast + b[k] * ylast + e[k];
         y = c[k] * xlast + d[k] * ylast + f[k];
         xlast = x;
         ylast = y;
         if (x &lt; xmin) xmin = x;
         if (y &lt; ymin) ymin = y;
         if (x &gt; xmax) xmax = x;
         if (y &gt; ymax) ymax = y;
         if (j == 1) {
            scale = MIN(NX / (xmax - xmin),NY / (ymax - ymin));
            xmid = (xmin + xmax) / 2;
            ymid = (ymin + ymax) / 2;
            ix = NX / 2 + (x - xmid) * scale;
            iy = NY / 2 + (y - ymid) * scale;
            DrawPixel(image,NX,NY,ix,iy,black);
         }
      }
   }

   WriteBitmap(stdout,image,NX,NY,2);
}
</pre>

</body>
</html>

